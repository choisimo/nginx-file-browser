import { type NextRequest, NextResponse } from "next/server"
import { promises as fs } from "fs"
import path from "path"

// 환경에 따른 기본 디렉토리 설정
const getStaticFilesRoot = () => {
  const envRoot = process.env.STATIC_FILES_ROOT
  if (envRoot) {
    return envRoot
  }
  return "./public/files"
}

const STATIC_FILES_ROOT = getStaticFilesRoot()

// GET 요청 - 파일 목록 조회
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const requestedPath = searchParams.get("path") || "/"
    const page = parseInt(searchParams.get("page") || "1")
    const limit = parseInt(searchParams.get("limit") || "20")

    // 경로 정규화 및 보안 검증
    const safePath = path.normalize(requestedPath).replace(/^(\.\.[\/\\])+/, "")
    const fullPath = path.join(STATIC_FILES_ROOT, safePath)

    // 경로 검증
    const resolvedPath = path.resolve(fullPath)
    const resolvedRoot = path.resolve(STATIC_FILES_ROOT)
    
    if (!resolvedPath.startsWith(resolvedRoot)) {
      return NextResponse.json(
        { error: "잘못된 경로입니다." },
        { status: 400 }
      )
    }

    // 디렉토리 존재 확인
    try {
      const stats = await fs.stat(fullPath)
      if (!stats.isDirectory()) {
        return NextResponse.json(
          { error: "요청된 경로가 디렉토리가 아닙니다." },
          { status: 400 }
        )
      }
    } catch (error) {
      return NextResponse.json(
        { error: "디렉토리를 찾을 수 없습니다." },
        { status: 404 }
      )
    }

    // 파일 목록 읽기
    const items = await fs.readdir(fullPath, { withFileTypes: true })
    
    // 파일 정보 수집
    const files = await Promise.all(
      items.map(async (item) => {
        const itemPath = path.join(fullPath, item.name)
        const stats = await fs.stat(itemPath)
        const relativePath = path.join(safePath, item.name).replace(/\\/g, "/")
        
        return {
          name: item.name,
          type: item.isDirectory() ? "directory" : "file",
          size: stats.size,
          lastModified: stats.mtime.toISOString(),
          path: relativePath.startsWith("/") ? relativePath : `/${relativePath}`,
          extension: item.isFile() ? path.extname(item.name).toLowerCase() : undefined
        }
      })
    )

    // 정렬 (디렉토리 먼저, 그 다음 파일명 순)
    files.sort((a, b) => {
      if (a.type === "directory" && b.type === "file") return -1
      if (a.type === "file" && b.type === "directory") return 1
      return a.name.localeCompare(b.name, "ko", { numeric: true })
    })

    // 페이지네이션
    const startIndex = (page - 1) * limit
    const endIndex = startIndex + limit
    const paginatedFiles = files.slice(startIndex, endIndex)

    return NextResponse.json({
      files: paginatedFiles,
      total: files.length,
      page,
      hasMore: endIndex < files.length
    })

  } catch (error) {
    console.error("Files API error:", error)
    return NextResponse.json(
      { error: "파일 목록을 불러오는데 실패했습니다." },
      { status: 500 }
    )
  }
}

// PATCH 요청 - 파일/디렉토리 이름 변경
export async function PATCH(request: NextRequest) {
  try {
    const body = await request.json()
    const { oldPath, newName } = body

    if (!oldPath || !newName || newName.includes('/') || newName.includes('..')) {
      return NextResponse.json({ error: "잘못된 파라미터입니다." }, { status: 400 })
    }

    const safeOldPath = path.normalize(oldPath).replace(/^(\.\.[\/\\])+/, "")
    const fullOldPath = path.join(STATIC_FILES_ROOT, safeOldPath)
    const newPath = path.join(path.dirname(fullOldPath), newName)

    const resolvedOldPath = path.resolve(fullOldPath)
    const resolvedNewPath = path.resolve(newPath)
    const resolvedRoot = path.resolve(STATIC_FILES_ROOT)

    if (!resolvedOldPath.startsWith(resolvedRoot) || !resolvedNewPath.startsWith(resolvedRoot)) {
      return NextResponse.json({ error: "잘못된 경로입니다." }, { status: 400 })
    }

    try {
      await fs.access(newPath)
      return NextResponse.json({ error: `이름이 이미 존재합니다: ${newName}` }, { status: 409 })
    } catch {
      // 새 경로가 존재하지 않으면 이름 변경 진행
      await fs.rename(fullOldPath, newPath)
      return NextResponse.json({ message: "이름이 성공적으로 변경되었습니다." }, { status: 200 })
    }

  } catch (error) {
    console.error("Rename error:", error)
    return NextResponse.json({ error: "이름 변경 중 오류가 발생했습니다." }, { status: 500 })
  }
}

// DELETE 요청 - 파일/디렉토리 삭제
export async function DELETE(request: NextRequest) {
  try {
    const { pathToDelete } = await request.json()

    if (!pathToDelete) {
      return NextResponse.json({ error: "삭제할 경로가 제공되지 않았습니다." }, { status: 400 })
    }

    const safePath = path.normalize(pathToDelete).replace(/^(\.\.[\/\\])+/, "")
    const fullPath = path.join(STATIC_FILES_ROOT, safePath)

    const resolvedPath = path.resolve(fullPath)
    const resolvedRoot = path.resolve(STATIC_FILES_ROOT)

    if (!resolvedPath.startsWith(resolvedRoot) || resolvedPath === resolvedRoot) {
      return NextResponse.json({ error: "잘못된 삭제 경로입니다." }, { status: 400 })
    }

    const stats = await fs.stat(fullPath)
    if (stats.isDirectory()) {
      await fs.rm(fullPath, { recursive: true, force: true })
    } else {
      await fs.unlink(fullPath)
    }

    return NextResponse.json({ message: "성공적으로 삭제되었습니다." }, { status: 200 })

  } catch (error) {
    console.error("Delete error:", error)
    if (error.code === 'ENOENT') {
      return NextResponse.json({ error: "삭제할 파일 또는 폴더가 존재하지 않습니다." }, { status: 404 })
    }
    return NextResponse.json({ error: "삭제 중 오류가 발생했습니다." }, { status: 500 })
  }
}
